function [X, res, iterstop] = pGKBSPR_DP(A, b, M, alpha, k, tol, reorth, eta)
    % pGKBSPR_DP uses the right subspace Z_k generated by pGKB as solution subspace,
    % and solves the general-form regularization problem
    %   min{||Ax-b||_{2}^2 + lambda x'*M*x}
    % by projecting it as
    %   min{x'*M*x} s.t. min||Ax-b||_2, where x \in span(Z_k) at the k-th step,
    % and using discrepancy princple (DP) to stop iteration early.
    %
    % Inputs:
    %   A: either (a) a full or sparse mxn matrix;
    %             (b) a matrix object that performs the matrix*vector operation
    %   b: right-hand side vector
    %   M: regularization matrix, symmetric positive semi-definite
    %   alpha: parameter to control the condition number of G
    %   k: the maximum number of iterations 
    %   tol: stopping tolerance of pcg.m for solving Gx = A'u
    %       if tol=0, then solve it directly 
    %   reorth: 
    %       0: no reorthogonalization
    %       1: full reorthogonaliation, MGS
    %       2: double reorthogonaliation, MGS
    %   eta: \tau*||e||_2 used in DP
    %
    % Outputs: 
    %   X: store the first k regularized solutions
    %   rel: strore residual norm of the first k regularized solution
    %   iterstop: the early seopping iteration estimated by DP
    % 
    % Reference: [1]. Haibo Li, A preconditioned Krylov subspace method for linear inverse 
    % problems with general-form Tikhonov regularization, preprint, 2023.
    % [2]. C. C. Paige & M. A. Saunders, "LSQR: an algorithm for sparse linear equations 
    % and sparse least squares", ACM Trans. Math. Software, 1982, 8, 43-71.
    %
    % Haibo Li, Institute of Computing Technology, Chinese Academy of Sciences
    % 04, July, 2023.
    % 
    % Check for acceptable number of input arguments
    if nargin < 8
        error('Not Enough Inputs')
    end
    
    if size(M,1) ~= size(M,2)
        error('M needs to be square')
    end

    [m, n] = sizem(A); 
    if n ~= size(M,1) || m~= size(b,1)
        error('The dimensions are not consistent')
    end


fprintf('Start the pGKB iteration ===========================================\n');
[bbeta, B, ~, Z] = pGKB(A, b, M, alpha, k, tol, reorth);

% Intialiazation
X = zeros(n, k); 
res = zeros(k,1);   
iterstop = 0;  % initialize the early stopping iteration
flag = 1;  % indicate wether we still need to estimate iterstop

fprintf('Start update procedure ===========================================\n');
w = Z(:,1);
phi_bar = bbeta;
rho_bar = B(1,1);
x = zeros(n, 1);

for l = 1:k
    % Construct and apply orthogonal transformation.
    rrho = sqrt(rho_bar^2 + B(l+1,l)^2);
    c = rho_bar/rrho;
    s =  B(l+1,l)/rrho;
    theta = s*B(l+1,l+1);
    rho_bar = -c*B(l+1,l+1);
    phi = c*phi_bar;
    phi_bar = s*phi_bar;

    % Update the solution.
    x = x + (phi/rrho)*w;
    w = Z(:,l+1) - (theta/rrho)*w;
    X(:,l) = x;
    res(l) = abs(phi_bar);  % residual norm

    % estimate optimal regularization step by MDP
    if flag == 1 && abs(phi_bar) <= eta
        iterstop = l;
        flag = 0;
    end
end
    
end
    
    