function [X, res, Lam, iterstop] = pGKBhyb_su(A, b, M, alpha, k, tol, reorth, eta)
    % pGKBhyb_su uses the right subspace Z_k generated by pGKB as solution subspace,
    % and solves the general-form regularization problem
    %   min{||Ax-b||_{2}^2 + lambda x'*M*x}
    % by hybrid regularization method, and using the secant update method
    % to update the regularization parameter at each iteration.
    %
    % Inputs:
    %   A: either (a) a full or sparse mxn matrix;
    %             (b) a matrix object that performs the matrix*vector operation
    %   b: right-hand side vector
    %   M: regularization matrix, symmetric positive semi-definite
    %   alpha: parameter to control the condition number of G
    %   k: the maximum number of iterations 
    %   tol: stopping tolerance of pcg.m for solving Gx = A'u
    %       if tol=0, then solve it directly 
    %   reorth: 
    %       0: no reorthogonalization
    %       1: full reorthogonaliation, MGS
    %       2: double reorthogonaliation, MGS
    %   eta: \tau*||e||_2 used in the secant update
    %
    % Outputs: 
    %   X: store the first k regularized solutions
    %   res: strore residual norm of the first k regularized solution
    %   Lam: stores the first k regularization parameters
    %   iterstop: the early seopping iteration estimated by DP
    % 
    % Reference: [1]. Haibo Li, A preconditioned Krylov subspace method for linear inverse 
    % problems with general-form Tikhonov regularization, preprint, 2023.
    % [2]. Silvia Gazzola, Paolo  Novati, "Automatic parameter setting for Arnoldi--Tikhonov 
    % methods", J. of Comp. & Appl. Math., 2014, 256, 180-195.
    %
    % Haibo Li, Institute of Computing Technology, Chinese Academy of Sciences
    % 05, July, 2023.
    %
    % Initialization of data
    if nargin < 8
        error('Not Enough Inputs')
    end
    
    if size(M,1) ~= size(M,2)
        error('M needs to be square')
    end

    [m, n] = sizem(A); 
    if n ~= size(M,1) || m~= size(b,1)
        error('The dimensions are not consistent')
    end

    X = zeros(n, k); 
    res = zeros(k,1); 
    Lam = zeros(k,1);  
    iterstop = 0;  % initialize the early stopping iteration
    terminate = 1;  % indicate wether we still need to estimate iterstopb
    step = 4;
    
    fprintf('Start the pGKB iteration ===========================================\n');
    [bbeta, B, ~, Z] = pGKB(A, b, M, alpha, k, tol, reorth);
    
    % Intialize secant update
    fprintf('Start the secont update iteration ===================================\n');
    phi_bar = bbeta;
    rho_bar = B(1,1);
    lam = 1.0;  % initialize lam
    Lam(1) = lam;

    % Start secant update iteration
    for l = 1:k 
        fprintf('Running secant update regularizing iteration: the %d-th step ======\n', l);
        % Construct and apply orthogonal transformation
        rrho = sqrt(rho_bar^2 + B(l+1,l)^2);
        c = rho_bar / rrho;
        s = B(l+1,l) / rrho;
        rho_bar = -c * B(l+1,l+1);  
        phi_bar = s*phi_bar;  % equals to ||Ax_k-b||
    
        % Update x_lam and lam by secant update
        e1 = zeros(l,1);  e1(1) = 1;
        b_lam = bbeta*B(1,1) * e1;
        B_lam = B(1:l+1,1:l)'*B(1:l+1,1:l) + lam*Z(:,1:l)'*M*Z(:,1:l);
        y_lam = B_lam \ b_lam;
        X(:,l) = Z(:,1:l) * y_lam;
        e11 = [1; zeros(l,1)];
        res_lam = norm(B(1:l+1,1:l)*y_lam - bbeta*e11);
        res(l) = res_lam;
        lam = abs((eta-phi_bar)/(res_lam-phi_bar)) * lam;  % update lam
        Lam(l+1) = lam;

        % estimate stopping iteration
        if (step+1) < l && terminate && res(l-step-1) <= eta % residual norm <= eta
            flag = 0;
            for i = 0:step
                % if abs(res(l-i)-eta)/eta > 1e-2
                %     % using a window of "step" iteration to find "flat" of residual
                %     flag = flag + 1;
                % end
                if abs((res(l-i)-res(l-i-1)))/res(l-i-1) > 1e-3
                    flag = flag + 1;
                end
            end
            if flag == 0
                iterstop = l;
                terminate = 0;
            end
        end
    end
    % check if the stopping iteration is satisfied
    if terminate == 1
        iterstop = k;
        fprintf('The secant update method has not been stabalized. \n');
    end

    Lam = Lam(1:k);  % discard the (k+1)-th lam   
end
    